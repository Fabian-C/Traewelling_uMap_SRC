<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tr√§welling Map Explorer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/core@^9.0.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/layers@^9.0.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/geo-layers@^9.0.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/mapbox@^9.0.0/dist.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f0f0f; --bg-secondary: #1a1a1a; --bg-tertiary: #252525;
            --text-primary: #ffffff; --text-secondary: #b0b0b0; --text-muted: #808080;
            --border-color: #333333; --hover-bg: #2a2a2a; --menu-bg: rgba(26, 26, 26, 0.95);
            --popup-bg: rgba(30, 30, 30, 0.95); --shadow: rgba(0, 0, 0, 0.3);
            --accent-color: #667eea; --accent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary); color: var(--text-primary); position: fixed; width: 100%; height: 100%; overflow: hidden; }
        .setup-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-primary);
            display: flex; align-items: center; justify-content: center; z-index: 10000; transition: opacity 0.5s ease; }
        .setup-screen.hidden { opacity: 0; pointer-events: none; }
        .setup-container { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 16px;
            padding: 40px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); }
        .setup-header { text-align: center; margin-bottom: 30px; }
        .setup-header h1 { font-size: 28px; margin: 0 0 10px; background: var(--accent-gradient);
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; color: transparent; }
        .setup-header p { color: var(--text-secondary); margin: 0; font-size: 14px; }
        .setup-form { display: flex; flex-direction: column; gap: 20px; }
        .form-group { display: flex; flex-direction: column; gap: 8px; }
        .form-group label { font-size: 14px; font-weight: 600; color: var(--text-secondary); }
        .form-group input { padding: 14px 16px; border: 1px solid var(--border-color); border-radius: 8px;
            background: var(--bg-primary); color: var(--text-primary); font-size: 16px; }
        .form-group input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2); }
        .form-hint { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .form-hint a { color: var(--accent-color); text-decoration: none; }
        .btn-primary { padding: 14px 24px; background: var(--accent-gradient); border: none; border-radius: 8px;
            color: white; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }
        .setup-divider { display: flex; align-items: center; gap: 15px; color: var(--text-muted); font-size: 12px; }
        .setup-divider::before, .setup-divider::after { content: ''; flex: 1; height: 1px; background: var(--border-color); }
        .saved-sessions { background: var(--bg-tertiary); border-radius: 8px; padding: 15px; }
        .saved-sessions h3 { font-size: 14px; margin: 0 0 10px; color: var(--text-secondary); }
        .session-item { display: flex; align-items: center; justify-content: space-between; padding: 10px;
            background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px; cursor: pointer; }
        .session-item:hover { background: var(--hover-bg); }
        .saved-account-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-secondary);
            border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; }
        .saved-account-item:hover { background: var(--hover-bg); }
        .saved-account-item.active { border-color: var(--accent-color); background: var(--bg-tertiary); }
        .saved-account-avatar { width: 36px; height: 36px; border-radius: 50%; background: var(--accent-color);
            display: flex; align-items: center; justify-content: center; font-weight: 700; color: white; flex-shrink: 0; }
        .saved-account-info { flex: 1; min-width: 0; }
        .saved-account-name { font-weight: 600; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .saved-account-meta { font-size: 11px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .saved-account-delete { background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 4px 8px;
            border-radius: 4px; font-size: 14px; opacity: 0.6; transition: all 0.2s; }
        .saved-account-delete:hover { opacity: 1; background: rgba(255,0,0,0.1); color: #ff4444; }
        .session-info { display: flex; align-items: center; gap: 10px; }
        .session-avatar { width: 36px; height: 36px; border-radius: 50%; background: var(--accent-gradient);
            display: flex; align-items: center; justify-content: center; font-weight: 600; }
        .session-delete { color: var(--text-muted); padding: 5px; border: none; background: none; cursor: pointer; }
        .session-delete:hover { color: #ff4444; }
        .fetch-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-primary);
            display: flex; align-items: center; justify-content: center; z-index: 9999; transition: opacity 0.5s ease; }
        .fetch-screen.hidden { opacity: 0; pointer-events: none; }
        .fetch-container { text-align: center; max-width: 500px; width: 90%; padding: 40px; }
        .fetch-spinner { width: 80px; height: 80px; border: 4px solid var(--bg-tertiary); border-top-color: var(--accent-color);
            border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 30px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .fetch-title { font-size: 24px; margin: 0 0 10px; }
        .fetch-status { color: var(--text-secondary); margin: 0 0 30px; font-size: 14px; }
        .fetch-progress-bar { height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden; margin-bottom: 15px; }
        .fetch-progress-fill { height: 100%; background: var(--accent-gradient); border-radius: 4px; transition: width 0.3s; width: 0%; }
        .fetch-stats { display: flex; justify-content: center; gap: 30px; color: var(--text-secondary); font-size: 14px; }
        .fetch-stat { display: flex; flex-direction: column; align-items: center; }
        .fetch-stat-value { font-size: 24px; font-weight: 600; color: var(--text-primary); }
        .fetch-stat-label { font-size: 12px; color: var(--text-muted); }
        .fetch-cancel { margin-top: 30px; padding: 10px 20px; background: transparent; border: 1px solid var(--border-color);
            border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 14px; }
        .fetch-error { color: #ff4444; background: rgba(255, 68, 68, 0.1); border: 1px solid rgba(255, 68, 68, 0.3);
            border-radius: 8px; padding: 15px; margin-top: 20px; font-size: 14px; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; height: 100%; background: var(--bg-primary); }
        .menu { position: absolute; top: 10px; right: 10px; z-index: 1000; background: var(--menu-bg);
            border: 1px solid var(--border-color); border-radius: 8px; min-width: 150px; font-size: 14px; backdrop-filter: blur(10px); }
        .menu summary { padding: 12px 16px; cursor: pointer; font-weight: 700; color: var(--text-primary);
            list-style: none; display: flex; align-items: center; justify-content: space-between; border-radius: 8px; min-height: 44px; }
        .menu summary::-webkit-details-marker { display: none; }
        .menu-content { padding: 0 0; border-top: 1px solid var(--border-color); }
        .menu-section { padding: 16px; border-bottom: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 12px; }
        .menu-section:last-of-type { border-bottom: none; }
        .menu-section-header { display: flex; justify-content: space-between; align-items: center; }
        .section-label { margin: 0; font-size: 13px; font-weight: 700; color: var(--text-primary); }
        .section-sub { margin: -6px 0 0; font-size: 11px; color: var(--text-secondary); }
        .account-card { display: flex; align-items: center; gap: 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 10px 12px; }
        .account-card.compact { padding: 8px 10px; }
        .account-avatar { width: 44px; height: 44px; border-radius: 50%; background: var(--accent-gradient); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 16px; color: white; overflow: hidden; background-size: cover; background-position: center; }
        .account-meta { flex: 1; min-width: 0; }
        .account-name { font-weight: 600; font-size: 14px; }
        .account-username { font-size: 12px; color: var(--text-secondary); }
        .btn-link { border: none; background: transparent; color: var(--accent-color); font-size: 12px; font-weight: 600; cursor: pointer; text-decoration: none; padding: 0; }
        .btn-link.hidden { display: none; }
        .menu-form-group { display: flex; flex-direction: column; gap: 6px; }
        .menu-form-group label { font-size: 12px; color: var(--text-secondary); font-weight: 600; }
        .menu-form-group input,
        .menu-form-group textarea { border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); padding: 10px 12px; font-size: 13px; resize: none; min-height: 44px; }
        .menu-actions { display: flex; gap: 8px; flex-wrap: wrap; }
        .btn-secondary,
        .btn-outline { flex: 1; min-width: 120px; border-radius: 8px; padding: 10px 12px; font-size: 13px; font-weight: 600; cursor: pointer; }
        .btn-secondary { background: var(--accent-gradient); color: #fff; border: none; }
        .btn-secondary:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-outline { background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); }
        .token-status { font-size: 12px; font-weight: 600; color: var(--text-secondary); }
        .token-status[data-state="success"] { color: #68d391; }
        .token-status[data-state="error"] { color: #ff6b6b; }
        .token-expiry { font-size: 11px; color: var(--text-muted); }
        .menu-divider { height: 1px; background: var(--border-color); margin: 0px 0; }
        .dataset-pill { font-size: 11px; font-weight: 600; color: var(--text-secondary); background: var(--bg-tertiary); padding: 4px 8px; border-radius: 12px; }
        .menu-item { padding: 12px 16px; cursor: pointer; color: var(--text-primary); font-weight: 600;
            display: flex; align-items: center; border-bottom: 1px solid var(--border-color); min-height: 44px; }
        .menu-item:last-child { border-bottom: none; }
        .menu-item:hover { background: var(--hover-bg); }
        .menu-item.active { background: var(--bg-tertiary); font-weight: 700; }
        .menu-submenu { border-top: 1px solid var(--border-color); }
        .menu-submenu summary { padding: 10px 16px; font-weight: 600; cursor: pointer; list-style: none;
            display: flex; align-items: center; justify-content: space-between; }
        .menu-submenu summary::-webkit-details-marker { display: none; }
        .menu-submenu[open] > summary { background: var(--bg-tertiary); }
        .menu-submenu-content { padding: 0; }
        .inner-submenu { border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
        .inner-submenu summary { padding: 10px 12px; cursor: pointer; font-size: 13px; background: var(--bg-tertiary); list-style: none; }
        .inner-submenu summary::-webkit-details-marker { display: none; }
        .inner-submenu[open] > summary { background: var(--accent-color); color: white; }
        .layer-list { max-height: 200px; overflow-y: auto; padding: 8px; }
        .layer-item { padding: 10px 12px; margin: 3px 0; background: var(--bg-secondary); border: none; border-radius: 8px;
            cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: 600;
            color: var(--text-primary); transition: all 0.2s ease; user-select: none; position: relative; min-height: 44px; }
        .layer-item:last-child { border-bottom: none; }
        .layer-item:hover { background: var(--hover-bg); transform: translateX(2px); }
        .layer-item.active { background: var(--bg-tertiary); color: var(--text-primary); font-weight: 700; }
        .layer-item.dragging { opacity: 0.5; transform: rotate(2deg) scale(1.05); }
        .layer-item.drag-over { border-top: 3px solid var(--accent-color); }
        .toggle { position: relative; width: 48px; height: 26px; display: inline-block; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-tertiary); transition: .3s; border-radius: 26px; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px;
            background: white; transition: .3s; border-radius: 50%; }
        input:checked+.toggle-slider { background: #3887be; }
        input:checked+.toggle-slider:before { transform: translateX(22px); }
        .slider-container { padding: 0 16px 16px; }
        .btn-share { width: calc(100% - 32px); margin: 8px 16px 16px; padding: 10px 14px; font-size: 13px;
            min-height: 40px; background: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-primary);
            border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
        .btn-share:hover { background: var(--hover-bg); }
        .time-filter { padding: 16px; }
        .slider-label { font-size: 12px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); }
        .slider { width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, #333, #555);
            outline: none; -webkit-appearance: none; appearance: none; cursor: pointer; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
            background: var(--accent-gradient); cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        .stats-panel { position: absolute; top: 10px; left: -320px; background: var(--menu-bg); padding: 8px;
            border: 1px solid var(--border-color); border-radius: 6px; z-index: 999; min-width: 160px; max-width: 180px;
            backdrop-filter: blur(10px); opacity: 0; transition: all 0.3s; pointer-events: none; }
        .stats-panel.active { transform: translateX(330px); opacity: 1; pointer-events: auto; }
        .stats-title { font-size: 13px; font-weight: 600; margin: 0 0 8px; }
        .stat-item { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 11px; }
        .stat-label { color: var(--text-secondary); }
        .stat-value { font-weight: 600; text-align: right; }
        .time-filter { padding: 16px; }
        .time-input-group { margin-bottom: 16px; }
        .time-input-group label { display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary); }
        .time-input-group input { width: 100%; padding: 10px 12px; border: 1px solid var(--border-color); border-radius: 6px;
            font-size: 16px; background: var(--bg-primary); color: var(--text-primary); min-height: 44px; }
        .btn { padding: 10px 16px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;
            font-size: 14px; font-weight: 600; background: var(--bg-secondary); color: var(--text-primary); }
        .btn:hover { background: var(--hover-bg); }
        .btn-share { width: calc(100% - 32px); margin: 8px 16px 16px; }
        .user-info { padding: 12px 16px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 10px; }
        .user-avatar { width: 32px; height: 32px; border-radius: 50%; background: var(--accent-gradient);
            display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; }
        .user-name { font-weight: 600; font-size: 14px; }
        .btn-logout { margin-left: auto; padding: 4px 8px; font-size: 12px; background: transparent;
            border: 1px solid var(--border-color); color: var(--text-muted); cursor: pointer; border-radius: 4px; }
        .btn-logout:hover { background: #ff4444; border-color: #ff4444; color: white; }
        .route-popup .mapboxgl-popup-content { padding: 10px; max-width: 280px; font-size: 12px; background: var(--popup-bg);
            color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 8px; backdrop-filter: blur(10px); }
        .route-popup .popup-link { color: #4fc3f7; text-decoration: none; }
        .route-popup .popup-expand-btn { background: transparent; border: 1px solid #4fc3f7; color: #4fc3f7;
            padding: 6px 12px; font-size: 11px; border-radius: 4px; cursor: pointer; margin-top: 6px; width: 100%; min-height: 36px; }
        @media (max-width: 768px) {
            .setup-container { padding: 30px 20px; }
            .setup-header h1 { font-size: 24px; }
            .menu { top: 5px; right: 5px; min-width: 180px; max-width: 75vw; font-size: 12px; }
            .menu-content { max-height: 70vh; overflow-y: auto; -webkit-overflow-scrolling: touch; }
            .menu-item { padding: 10px 14px; min-height: 44px; }
            .menu-submenu summary { padding: 10px 14px; min-height: 44px; }
            .layer-item { padding: 10px; min-height: 44px; touch-action: manipulation; }
            .layer-list { max-height: 150px; -webkit-overflow-scrolling: touch; }
            .toggle { width: 44px; height: 24px; }
            .toggle-slider:before { height: 18px; width: 18px; }
            input:checked+.toggle-slider:before { transform: translateX(20px); }
            .stats-panel { top: 5px; left: -50vw; min-width: 48vw; max-width: 50vw; font-size: 11px; }
            .stats-panel.active { transform: translateX(52vw); }
            .btn-share { padding: 12px; min-height: 44px; }
            .account-card { padding: 10px; }
            .account-avatar { width: 36px; height: 36px; font-size: 14px; }
        }
        @media (max-width: 375px) {
            .menu { max-width: 85vw; }
            .stats-panel { min-width: 42vw; max-width: 45vw; font-size: 10px; }
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <!-- Setup Screen -->
    <div class="setup-screen" id="setupScreen">
        <div class="setup-container">
            <div class="setup-header">
                <h1>üöÇ Tr√§welling Map Explorer</h1>
                <p>Visualize your travel history on an interactive map</p>
            </div>
            <div class="setup-form">
                <div class="form-group">
                    <label for="apiToken">API Token (optional)</label>
                    <input type="password" id="apiToken" placeholder="Optional - for private profiles or higher rate limits">
                    <p class="form-hint">Required for private profiles only. Get your token from <a href="https://traewelling.de/settings/security/api-tokens" target="_blank">Tr√§welling Settings ‚Üí API-Tokens</a></p>
                </div>
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Enter username to explore">
                    <p class="form-hint">The Tr√§welling username whose trips you want to view</p>
                </div>
                <button class="btn-primary" id="startFetchBtn">üöÄ Load Travel Data</button>
                <div class="setup-divider">or</div>
                <div class="saved-sessions" id="savedSessions" style="display: none;">
                    <h3>üìÅ Recent Sessions</h3>
                    <div id="sessionsList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fetch Progress Screen -->
    <div class="fetch-screen hidden" id="fetchScreen">
        <div class="fetch-container">
            <div class="fetch-spinner"></div>
            <h2 class="fetch-title">Fetching Travel Data</h2>
            <p class="fetch-status" id="fetchStatus">Connecting to Tr√§welling API...</p>
            <div class="fetch-progress-bar"><div class="fetch-progress-fill" id="fetchProgress"></div></div>
            <div class="fetch-stats">
                <div class="fetch-stat"><span class="fetch-stat-value" id="fetchTrips">0</span><span class="fetch-stat-label">Trips</span></div>
                <div class="fetch-stat"><span class="fetch-stat-value" id="fetchPages">0</span><span class="fetch-stat-label">Pages</span></div>
                <div class="fetch-stat"><span class="fetch-stat-value" id="fetchPolylines">0</span><span class="fetch-stat-label">Routes</span></div>
            </div>
            <div class="fetch-error hidden" id="fetchError"></div>
            <button class="fetch-cancel" id="cancelFetchBtn">Cancel</button>
        </div>
    </div>

    <!-- Map -->
    <div id="map"></div>

    <!-- Stats Panel -->
    <div class="stats-panel" id="statsPanel">
        <h3 class="stats-title">üìä Statistics</h3>
        <div class="stat-item"><span class="stat-label">Total Trips:</span><span class="stat-value" id="statTrips">0</span></div>
        <div class="stat-item"><span class="stat-label">Total Distance:</span><span class="stat-value" id="statDistance">0 km</span></div>
        <div class="stat-item"><span class="stat-label">Most Used Line:</span><span class="stat-value" id="statLine">-</span></div>
        <div class="stat-item"><span class="stat-label">Most Used Type:</span><span class="stat-value" id="statType">-</span></div>
        <div class="stat-item"><span class="stat-label">Oldest Check-in:</span><span class="stat-value" id="statOldestDate">-</span></div>
        <div class="stat-item"><span class="stat-label">Newest Check-in:</span><span class="stat-value" id="statNewestDate">-</span></div>
    </div>

    <!-- Menu -->
    <details class="menu" id="mainMenu" style="display: none;">
        <summary>‚ò∞ Menu</summary>
        <div class="menu-content">
            <details class="menu-submenu" data-module="account">
                <summary>üë§ Account & Data</summary>
                <div style="padding: 16px; display: flex; flex-direction: column; gap: 12px;">
                    <!-- Account Status -->
                    <div class="account-card">
                        <div class="account-avatar" id="tokenOwnerAvatar" data-initial="?"></div>
                        <div class="account-meta">
                            <div class="account-name" id="tokenOwnerName">Not authenticated</div>
                            <div class="account-username" id="tokenOwnerUsername">@unknown</div>
                        </div>
                        <a class="btn-link" id="tokenOwnerProfileLink" href="#" target="_blank" rel="noopener">Profile</a>
                    </div>
                    <div class="token-status" id="tokenStatusText">Token not validated</div>
                    <div class="token-expiry" id="tokenExpiryText">‚Äî</div>
                    
                    <!-- API Token -->
                    <details class="inner-submenu">
                        <summary>üîë API Token</summary>
                        <div style="padding: 12px 0; display: flex; flex-direction: column; gap: 12px;">
                            <div class="menu-form-group">
                                <label for="menuApiToken">API Token (optional)</label>
                                <textarea id="menuApiToken" rows="3" placeholder="Optional - for private profiles"></textarea>
                            </div>
                            <div class="menu-actions">
                                <button class="btn-secondary" id="menuValidateBtn">Validate Token</button>
                                <button class="btn-outline" id="menuCopyTokenBtn">Copy Token</button>
                            </div>
                        </div>
                    </details>
                    
                    <!-- Target User -->
                    <details class="inner-submenu">
                        <summary>üéØ Target User</summary>
                        <div style="padding: 12px 0; display: flex; flex-direction: column; gap: 12px;">
                            <p class="section-sub" style="margin: 0;">Select whose travel data to display</p>
                            <div class="menu-form-group">
                                <label for="menuUsername">Username to query</label>
                                <input type="text" id="menuUsername" placeholder="e.g. Adriii666">
                            </div>
                            <button class="btn-primary" id="menuFetchBtn">Fetch Latest Data</button>
                        </div>
                    </details>
                    
                    <!-- Saved Accounts -->
                    <details class="inner-submenu">
                        <summary>üë• Saved Accounts</summary>
                        <div style="padding: 12px 0; display: flex; flex-direction: column; gap: 8px;">
                            <p class="section-sub" style="margin: 0;">Switch between cached accounts (highlighted = active)</p>
                            <div id="savedAccountsList">
                                <p class="section-sub" style="margin: 0; text-align: center;">No saved accounts</p>
                            </div>
                        </div>
                    </details>
                    
                    <button class="btn-logout" id="logoutBtn" style="width: 100%; margin-top: 8px;">Logout</button>
                </div>
            </details>

            <div class="menu-divider"></div>

            <div class="menu-item" id="statsToggle"><span>üìä Statistics</span></div>
            <details class="menu-submenu">
                <summary>üìÖ Time Filter</summary>
                <div class="menu-submenu-content">
                    <div class="time-filter">
                        <div class="time-input-group"><label for="dateFrom">From</label><input type="date" id="dateFrom"></div>
                        <div class="time-input-group"><label for="dateTo">To</label><input type="date" id="dateTo"></div>
                    </div>
                </div>
            </details>
            <details class="menu-submenu">
                <summary>üö¶ Transport Layers</summary>
                <div class="menu-submenu-content">
                    <div class="menu-item" style="padding: 12px 16px;">
                        <span style="margin-right: 10px;">Hide Inaccurate</span>
                        <label class="toggle">
                            <input type="checkbox" id="inaccurateDataToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-list" id="layerList">
                        <!-- Layers will be added dynamically -->
                    </div>
                </div>
            </details>
            <details class="menu-submenu">
                <summary>üî• Route Density</summary>
                <div class="menu-submenu-content">
                    <div class="menu-item" style="padding: 12px 16px;">
                        <span style="margin-right: 10px;">Show</span>
                        <label class="toggle">
                            <input type="checkbox" id="heatmapToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">Intensity: <span id="intensityValue">3</span></div>
                        <input type="range" class="slider" id="intensitySlider" min="1" max="5" value="3">
                    </div>
                    <div style="padding: 10px 16px; font-size: 11px; border-top: 1px solid var(--border-color); margin-top: 10px;">
                        <div style="margin-bottom: 5px; font-weight: 600;">Density Legend:</div>
                        <div style="display: flex; align-items: center; margin-bottom: 3px;">
                            <div style="width: 20px; height: 3px; background: rgb(59, 130, 246); margin-right: 8px;"></div>
                            <span>Low</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 3px;">
                            <div style="width: 20px; height: 3px; background: rgb(6, 182, 212); margin-right: 8px;"></div>
                            <span>Medium</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 3px;">
                            <div style="width: 20px; height: 3px; background: rgb(245, 158, 11); margin-right: 8px;"></div>
                            <span>High</span>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <div style="width: 20px; height: 3px; background: rgb(239, 68, 68); margin-right: 8px;"></div>
                            <span>Very High</span>
                        </div>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="animateToggle" checked style="margin-right: 8px;">
                                <span>Wave Animation</span>
                            </label>
                        </div>
                    </div>
                </div>
            </details>
            <div class="menu-item" id="railwayToggle"><span>üõ§Ô∏è Railway Map</span></div>
            <button class="btn btn-share" id="shareBtn">üîó Share View</button>
        </div>
    </details>

    <script>
    // =========================================================================
    // STATE & CONFIG
    // =========================================================================
    const state = {
        map: null,
        deck: null,
        deckLayers: [],
        currentPopup: null,
        token: null,
        username: null,
        tokenOwner: { username: null, displayName: null, avatar: null, profileUrl: null, validated: false },
        fetchedTrips: [],
        filters: { fromDate: null, toDate: null, hideInaccurate: false },
        railway: { enabled: false },
        heatmap: { enabled: false, animate: false, animationFrameId: null, intensity: 3, densityCache: null },
        layers: { 
            data: new Map(), 
            order: [
                'unknown',
                'plane',
                'bus',
                'ship',
                'tram',
                'subway',
                'suburban',
                'regional',
                'national',
                'regionalExp',
                'nationalExpress'
            ]
        },
        statistics: { trips: 0, distance: 0, lineCounts: {}, typeCounts: {}, oldestDate: null, newestDate: null, oldestStatusId: null, newestStatusId: null },
        cache: new Map(),
        cacheTimestamps: new Map()
    };

    const CONFIG = {
        MAPBOX_TOKEN: 'pk.eyJ1IjoiaGFzaGVyMTEiLCJhIjoiY2xhbzFubnJ2MHYyeDNvbGJ0N2E4ZGtmcCJ9.Y85sMCOsQLFIyxA7RTO7WA',
        API_BASE_URL: 'https://traewelling.de/api/v1',
        RATE_LIMIT: 55, RATE_WINDOW: 60000,
        LAYER_CONFIG: [
            ['nationalExpress', '#0073ff'],
            ['national', '#00eeff'],
            ['regionalExp', '#d1024e'],
            ['regional', '#a6026c'],
            ['suburban', '#fc0000'],
            ['bus', '#238443'],
            ['tram', '#2FC5CC'],
            ['subway', '#F69A00'],
            ['plane', '#111111'],
            ['ship', '#0055aa'],
            ['unknown', '#888888']
        ],
    };

    // =========================================================================
    // UI MODULE
    // =========================================================================
    const UI = {
        init() {
            this.refs = {
                setupScreen: document.getElementById('setupScreen'),
                fetchScreen: document.getElementById('fetchScreen'),
                fetchStatus: document.getElementById('fetchStatus'),
                fetchProgress: document.getElementById('fetchProgress'),
                fetchTrips: document.getElementById('fetchTrips'),
                fetchPages: document.getElementById('fetchPages'),
                fetchRoutes: document.getElementById('fetchPolylines'),
                fetchError: document.getElementById('fetchError'),
                menu: document.getElementById('mainMenu'),
                tokenOwnerAvatar: document.getElementById('tokenOwnerAvatar'),
                tokenOwnerName: document.getElementById('tokenOwnerName'),
                tokenOwnerUsername: document.getElementById('tokenOwnerUsername'),
                tokenOwnerProfileLink: document.getElementById('tokenOwnerProfileLink'),
                tokenStatusText: document.getElementById('tokenStatusText'),
                tokenExpiryText: document.getElementById('tokenExpiryText'),
                menuApiToken: document.getElementById('menuApiToken'),
                menuUsername: document.getElementById('menuUsername'),
                menuValidateBtn: document.getElementById('menuValidateBtn'),
                menuCopyTokenBtn: document.getElementById('menuCopyTokenBtn'),
                menuFetchBtn: document.getElementById('menuFetchBtn'),
                setupTokenInput: document.getElementById('apiToken'),
                setupUsernameInput: document.getElementById('username')
            };
        },
        toggleSetup(show) {
            if (!this.refs) return;
            this.refs.setupScreen.classList.toggle('hidden', !show);
        },
        toggleFetch(show) {
            if (!this.refs) return;
            this.refs.fetchScreen.classList.toggle('hidden', !show);
        },
        updateFetchStats({ trips, pages, routes, progress, status }) {
            if (!this.refs) return;
            if (typeof trips === 'number') this.refs.fetchTrips.textContent = trips;
            if (typeof pages === 'number') this.refs.fetchPages.textContent = pages;
            if (typeof routes === 'number') this.refs.fetchRoutes.textContent = routes;
            if (typeof progress === 'number') this.refs.fetchProgress.style.width = `${Math.min(100, progress)}%`;
            if (status) this.refs.fetchStatus.textContent = status;
        },
        setTokenOwner(owner) {
            if (!this.refs) return;
            const { tokenOwnerAvatar, tokenOwnerName, tokenOwnerUsername, tokenOwnerProfileLink } = this.refs;
            if (tokenOwnerAvatar) {
                if (owner?.avatar) {
                    tokenOwnerAvatar.style.backgroundImage = `url(${owner.avatar})`;
                    tokenOwnerAvatar.textContent = '';
                } else {
                    tokenOwnerAvatar.style.backgroundImage = 'none';
                    tokenOwnerAvatar.textContent = (owner?.displayName || owner?.username || '?')[0]?.toUpperCase() || '?';
                }
            }
            if (tokenOwnerName) tokenOwnerName.textContent = owner?.displayName || 'Not authenticated';
            if (tokenOwnerUsername) tokenOwnerUsername.textContent = owner?.username ? `@${owner.username}` : '@unknown';
            if (tokenOwnerProfileLink) {
                if (owner?.profileUrl) {
                    tokenOwnerProfileLink.classList.remove('hidden');
                    tokenOwnerProfileLink.href = owner.profileUrl;
                } else {
                    tokenOwnerProfileLink.classList.add('hidden');
                    tokenOwnerProfileLink.removeAttribute('href');
                }
            }
        },
        setTokenStatus(message, state = 'idle', expiryText = '') {
            if (!this.refs) return;
            this.refs.tokenStatusText.textContent = message;
            this.refs.tokenStatusText.dataset.state = state;
            this.refs.tokenExpiryText.textContent = expiryText || '‚Äî';
        },
        syncTokenInputs(token) {
            if (!this.refs) return;
            if (token !== undefined) {
                this.refs.menuApiToken.value = token;
                if (this.refs.setupTokenInput) this.refs.setupTokenInput.value = token;
            }
        },
        syncUsernameInput(username) {
            if (!this.refs) return;
            if (username !== undefined) {
                this.refs.menuUsername.value = username;
                if (this.refs.setupUsernameInput) this.refs.setupUsernameInput.value = username;
            }
        },
        updateDatasetSummary(displayNameOrUsername, usernameOrTripCount, tripCountOrPicture, profilePicture) {
            if (!this.refs) return;
            
            // Handle both old (username, tripCount) and new (displayName, username, tripCount, picture) signatures
            let displayName, username, tripCount, picture;
            if (typeof usernameOrTripCount === 'number') {
                // Old signature: (username, tripCount)
                username = displayNameOrUsername;
                displayName = displayNameOrUsername;
                tripCount = usernameOrTripCount;
                picture = tripCountOrPicture;
            } else {
                // New signature: (displayName, username, tripCount, picture)
                displayName = displayNameOrUsername;
                username = usernameOrTripCount;
                tripCount = tripCountOrPicture;
                picture = profilePicture;
            }
            
            const datasetAvatar = document.getElementById('datasetAvatar');
            const datasetName = document.getElementById('datasetName');
            const datasetUsername = document.getElementById('datasetUsername');
            const datasetTrips = document.getElementById('datasetTrips');
            
            if (datasetAvatar) {
                if (picture) {
                    datasetAvatar.style.backgroundImage = `url('${picture}')`;
                    datasetAvatar.style.backgroundSize = 'cover';
                    datasetAvatar.textContent = '';
                } else {
                    datasetAvatar.style.backgroundImage = '';
                    datasetAvatar.textContent = username ? username[0].toUpperCase() : '?';
                }
            }
            if (datasetName) {
                datasetName.textContent = displayName || 'No data loaded';
            }
            if (datasetUsername) {
                datasetUsername.textContent = username ? `@${username}` : '@‚Äî';
            }
            if (datasetTrips) {
                datasetTrips.textContent = `${tripCount || 0} trips`;
            }
        }
    };

    // =========================================================================
    // RATE-LIMITED API CLIENT
    // =========================================================================
    class TraewellingAPI {
        constructor(token = null) { this.token = token; this.requestTimes = []; }

        async waitForRateLimit() {
            const now = Date.now();
            this.requestTimes = this.requestTimes.filter(t => now - t < CONFIG.RATE_WINDOW);
            if (this.requestTimes.length >= CONFIG.RATE_LIMIT) {
                const waitTime = CONFIG.RATE_WINDOW - (now - Math.min(...this.requestTimes)) + 100;
                console.log(`Rate limit: waiting ${waitTime}ms`);
                await new Promise(r => setTimeout(r, waitTime));
            }
            this.requestTimes.push(Date.now());
        }

        async request(endpoint, requireAuth = false) {
            await this.waitForRateLimit();
            const headers = { 'Accept': 'application/json' };
            if (this.token || requireAuth) {
                headers['Authorization'] = `Bearer ${this.token}`;
            }
            const response = await fetch(`${CONFIG.API_BASE_URL}${endpoint}`, { headers });
            if (!response.ok) throw new Error(`API Error: ${response.status} ${response.statusText}`);
            return response.json();
        }

        getUserStatuses(username, page = 1) { return this.request(`/user/${username}/statuses?page=${page}`); }
        getPolyline(statusId) { return this.request(`/polyline/${statusId}`).catch(() => null); }
        getPolylines(statusIds) { return this.request(`/polyline/${statusIds.join(',')}`).catch(() => null); }
        getAuthenticatedUser() { return this.request('/auth/user', true); }
        getPublicUser(username) { return this.request(`/user/${username}`); }
    }

    // =========================================================================
    // DATA FETCHING
    // =========================================================================
    async function startDataFetch() {
        const token = state.token || document.getElementById('apiToken').value.trim();
        const username = state.username || document.getElementById('username').value.trim();
        if (!username) return alert('Please enter a username');

        state.token = token; state.username = username; state.isFetching = true;
        state.cancelFetch = false; state.fetchedTrips = [];
        UI.toggleSetup(false);
        UI.toggleFetch(true);

        const api = new TraewellingAPI(token);
        try {
            // Only validate token if provided
            if (token) {
                UI.updateFetchStats({ status: 'Validating token...' });
                const user = await api.getAuthenticatedUser();
                state.tokenOwner = {
                    username: user.data.username,
                    displayName: user.data.displayName,
                    avatar: user.data.profilePicture,
                    profileUrl: `https://traewelling.de/profile/${user.data.username}`,
                    validated: true
                };
                UI.setTokenOwner(state.tokenOwner);
                UI.setTokenStatus('Token valid', 'success');
            } else {
                UI.updateFetchStats({ status: 'Fetching public data...' });
                UI.setTokenStatus('No token (public access)', 'idle');
            }

            let page = 1, hasMore = true;
            const allStatuses = [];

            while (hasMore && !state.cancelFetch) {
                UI.updateFetchStats({ status: `Fetching page ${page}...` });
                const response = await api.getUserStatuses(username, page);
                if (!response?.data?.length) { hasMore = false; break; }
                allStatuses.push(...response.data);
                UI.updateFetchStats({ trips: allStatuses.length, pages: page });
                hasMore = !!response.links?.next;
                page++;
                if (page > 500) break;
            }

            if (state.cancelFetch) return showFetchError('Cancelled');

            UI.updateFetchStats({ status: 'Fetching route polylines...' });
            let polylineCount = 0;
            const tripsWithTrain = allStatuses.filter(s => s.train);
            const batchSize = 15; // Match API page size
            
            // Process polylines in batches
            for (let i = 0; i < tripsWithTrain.length && !state.cancelFetch; i += batchSize) {
                const batch = tripsWithTrain.slice(i, i + Math.min(batchSize, tripsWithTrain.length - i));
                const statusIds = batch.map(s => s.id);
                
                UI.updateFetchStats({ status: `Fetching polylines: batch ${Math.floor(i/batchSize)+1}/${Math.ceil(tripsWithTrain.length/batchSize)}` });
                
                const polylinesData = await api.getPolylines(statusIds);
                
                if (polylinesData?.data?.features) {
                    // The polyline API returns a FeatureCollection
                    polylinesData.data.features.forEach(feature => {
                        if (feature?.properties?.statusId) {
                            const status = allStatuses.find(s => s.id === feature.properties.statusId);
                            if (status && status.train) {
                                status.train.polyline = feature;
                                polylineCount++;
                            }
                        }
                    });
                }
                
                UI.updateFetchStats({ routes: polylineCount, progress: ((i + batch.length) / tripsWithTrain.length) * 100 });
            }

            state.fetchedTrips = allStatuses;
            saveSession(username, allStatuses, state.token);
            UI.updateFetchStats({ status: 'Processing data...' });
            await processAndDisplayData(allStatuses);
        } catch (error) {
            console.error('Fetch error:', error);
            showFetchError(error.message);
        }
    }

    function cancelFetch() { state.cancelFetch = true; state.isFetching = false; }
    function updateFetchStatus(msg) { document.getElementById('fetchStatus').textContent = msg; }

    function showFetchError(msg) {
        const errorEl = document.getElementById('fetchError');
        errorEl.textContent = msg; errorEl.classList.remove('hidden');
        document.getElementById('cancelFetchBtn').textContent = 'Back to Setup';
        document.getElementById('cancelFetchBtn').onclick = () => {
            UI.toggleFetch(false);
            UI.toggleSetup(true);
            errorEl.classList.add('hidden');
            document.getElementById('cancelFetchBtn').textContent = 'Cancel';
            document.getElementById('cancelFetchBtn').onclick = cancelFetch;
        };
    }

    // =========================================================================
    // DATA PROCESSING
    // =========================================================================
    function processTripsToGeoJSON(trips) {
        const categories = {};
        CONFIG.LAYER_CONFIG.forEach(([cat]) => { categories[cat] = { type: 'FeatureCollection', features: [] }; });

        trips.forEach(trip => {
            const category = trip.train?.category || 'unknown';
            const targetCat = categories[category] ? category : 'unknown';
            const polyline = trip.train?.polyline;
            if (!polyline?.geometry?.coordinates) return;

            categories[targetCat].features.push({
                type: 'Feature',
                geometry: polyline.geometry,
                properties: { statusId: trip.id, createdAt: trip.createdAt, train: trip.train, body: trip.body }
            });
        });
        return categories;
    }

    function filterInaccurateData(data, category) {
        if (!state.filters.hideInaccurate) return data;
        const filtered = data.features.filter(f => {
            const coords = f.geometry?.coordinates;
            if (!coords || coords.length < 2) return false;
            if (category === 'plane' || category === 'ship') return true;

            let totalDist = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                const [x1,y1] = coords[i], [x2,y2] = coords[i+1];
                totalDist += Math.sqrt((x2-x1)**2 + (y2-y1)**2);
            }

            if (coords.length <= 10) {
                let threshold = 0.1;
                if (['bus','tram','subway'].includes(category)) threshold = 0.05;
                else if (['regional','regionalExp'].includes(category)) threshold = 0.2;
                else if (['national','nationalExpress'].includes(category)) threshold = 0.3;
                if (totalDist > threshold) return false;
            }
            if (totalDist > 0.3 && totalDist / coords.length > 0.027) return false;
            return true;
        });
        return { type: 'FeatureCollection', features: filtered };
    }

    // =========================================================================
    // SESSION MANAGEMENT
    // =========================================================================
    
    // Fetch user profile from API
    async function fetchUserProfile(username, token) {
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/user/${username}`, {
                headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
            });
            if (!response.ok) return null;
            const data = await response.json();
            return {
                username: data.data?.username || username,
                displayName: data.data?.displayName || username,
                profilePicture: data.data?.profilePicture || null,
                profileUrl: `https://traewelling.de/@${username}`
            };
        } catch (e) {
            console.warn('Failed to fetch user profile:', e);
            return null;
        }
    }
    
    // Save session with token and profile
    async function saveSession(username, trips, token = null) {
        try {
            const sessions = JSON.parse(localStorage.getItem('tw_sessions') || '{}');
            const existingSession = sessions[username] || {};
            
            // Fetch profile if we have a token
            let profile = existingSession.profile || null;
            if (token) {
                const fetchedProfile = await fetchUserProfile(username, token);
                if (fetchedProfile) profile = fetchedProfile;
            }
            
            sessions[username] = {
                trips,
                token: token || existingSession.token || null,
                profile,
                savedAt: new Date().toISOString(),
                tripCount: trips.length
            };
            localStorage.setItem('tw_sessions', JSON.stringify(sessions));
            loadSavedSessions();
            updateMenuAccountList();
        } catch (e) { console.warn('Save session failed:', e); }
    }

    function loadSavedSessions() {
        try {
            const sessions = JSON.parse(localStorage.getItem('tw_sessions') || '{}');
            const list = document.getElementById('sessionsList');
            const container = document.getElementById('savedSessions');
            if (!Object.keys(sessions).length) { container.style.display = 'none'; return; }
            container.style.display = 'block';
            list.innerHTML = '';
            Object.entries(sessions).forEach(([username, data]) => {
                const item = document.createElement('div');
                item.className = 'session-item';
                const avatarStyle = data.profile?.profilePicture 
                    ? `background-image: url('${data.profile.profilePicture}'); background-size: cover;`
                    : '';
                const avatarContent = data.profile?.profilePicture ? '' : username[0].toUpperCase();
                const displayName = data.profile?.displayName || username;
                item.innerHTML = `
                    <div class="session-info">
                        <div class="session-avatar" style="${avatarStyle}">${avatarContent}</div>
                        <span>${displayName} (${data.tripCount} trips)</span>
                    </div>
                    <button class="session-delete" onclick="event.stopPropagation();deleteSession('${username}')">‚úï</button>`;
                item.onclick = () => loadSession(username);
                list.appendChild(item);
            });
        } catch (e) { console.warn('Load sessions failed:', e); }
    }

    function loadSession(username) {
        try {
            const sessions = JSON.parse(localStorage.getItem('tw_sessions') || '{}');
            const session = sessions[username];
            if (!session) return alert('Session not found');
            
            // Restore state
            state.username = username;
            state.fetchedTrips = session.trips;
            
            // Restore token if available
            if (session.token) {
                state.token = session.token;
                UI.syncTokenInputs(session.token);
            }
            
            // Update UI with profile info
            if (session.profile) {
                UI.updateDatasetSummary(session.profile.displayName, username, session.tripCount, session.profile.profilePicture);
            }
            
            UI.syncUsernameInput(username);
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('mainMenu').style.display = '';
            processAndDisplayData(session.trips);
            
            // Update statistics after loading session
            updateAllStatistics();
        } catch (e) { alert('Failed to load session'); }
    }

    function deleteSession(username) {
        const sessions = JSON.parse(localStorage.getItem('tw_sessions') || '{}');
        delete sessions[username];
        localStorage.setItem('tw_sessions', JSON.stringify(sessions));
        loadSavedSessions();
        updateMenuAccountList();
    }
    
    // Update account list in menu
    function updateMenuAccountList() {
        const container = document.getElementById('savedAccountsList');
        if (!container) return;
        
        try {
            const sessions = JSON.parse(localStorage.getItem('tw_sessions') || '{}');
            const sessionList = Object.entries(sessions);
            
            if (!sessionList.length) {
                container.innerHTML = '<p class="section-sub" style="margin: 0; text-align: center;">No saved accounts</p>';
                return;
            }
            
            container.innerHTML = sessionList.map(([username, data]) => {
                const avatarStyle = data.profile?.profilePicture 
                    ? `background-image: url('${data.profile.profilePicture}'); background-size: cover;`
                    : '';
                const avatarContent = data.profile?.profilePicture ? '' : username[0].toUpperCase();
                const displayName = data.profile?.displayName || username;
                const isActive = state.username === username ? 'active' : '';
                const date = new Date(data.savedAt).toLocaleDateString();
                
                return `
                    <div class="saved-account-item ${isActive}" onclick="loadSession('${username}')">
                        <div class="saved-account-avatar" style="${avatarStyle}">${avatarContent}</div>
                        <div class="saved-account-info">
                            <div class="saved-account-name">${displayName}</div>
                            <div class="saved-account-meta">@${username} ¬∑ ${data.tripCount} trips ¬∑ ${date}</div>
                        </div>
                        <button class="saved-account-delete" onclick="event.stopPropagation();deleteSession('${username}')">‚úï</button>
                    </div>
                `;
            }).join('');
        } catch (e) { console.warn('Failed to update menu account list:', e); }
    }

    function logout() {
        state.token = null; state.username = null; state.fetchedTrips = [];
        state.tokenOwner = { username: null, displayName: null, avatar: null, profileUrl: null, validated: false };
        state.layers.data.clear();
        CONFIG.LAYER_CONFIG.forEach(([id]) => {
            if (state.map?.getLayer(id)) state.map.removeLayer(id);
            if (state.map?.getSource(id)) state.map.removeSource(id);
        });
        UI.refs.menu.style.display = 'none';
        UI.toggleSetup(true);
        UI.setTokenOwner(null);
        UI.setTokenStatus('Token not validated', 'idle');
        UI.updateDatasetSummary(null, 0);
    }

    // =========================================================================
    // MAP INITIALIZATION & DISPLAY
    // =========================================================================
    async function processAndDisplayData(trips) {
        // Update dataset summary in menu
        UI.updateDatasetSummary(state.username, trips.length);

        const categories = processTripsToGeoJSON(trips);

        if (!state.map) {
            initMap();
            await new Promise(r => state.map.on('load', r));
        }

        // Add layers with mobile compatibility
        const addRouteLayers = () => {
            for (let i = 0; i < state.layers.order.length; i++) {
                const layerId = state.layers.order[i];
                const config = CONFIG.LAYER_CONFIG.find(([id]) => id === layerId);
                if (!config) continue;
                const [_, color] = config;
                let data = categories[layerId] || { type: 'FeatureCollection', features: [] };
                if (state.filters.hideInaccurate) data = filterInaccurateData(data, layerId);

                // Remove existing layer if present
                if (state.map.getLayer(layerId)) {
                    try {
                        state.map.removeLayer(layerId);
                    } catch (e) {
                        console.warn(`Failed to remove layer ${layerId}:`, e);
                    }
                }
                if (state.map.getSource(layerId)) {
                    try {
                        state.map.removeSource(layerId);
                    } catch (e) {
                        console.warn(`Failed to remove source ${layerId}:`, e);
                    }
                }

                try {
                    state.map.addSource(layerId, { type: 'geojson', data });
                    state.map.addLayer({
                        id: layerId, type: 'line', source: layerId,
                        layout: { 'line-join': 'round', 'line-cap': 'round', visibility: state.heatmap.enabled ? 'none' : 'visible' },
                        paint: { 'line-color': color, 'line-width': ['interpolate', ['linear'], ['zoom'], 12, 3, 18, 16], 'line-opacity': 0.8 }
                    }, i > 0 ? state.layers.order[i-1] : 'open-railway-map');

                    state.layers.data.set(layerId, { data, color, visible: true });
                    updateStatistics(data, layerId);
                } catch (e) {
                    console.error(`Failed to add layer ${layerId}:`, e);
                }
            }
        };
        
        // On mobile, wait a bit for the map to be ready
        if (RouteAnimation.isMobile()) {
            setTimeout(() => {
                addRouteLayers();
                // Load layers immediately after adding routes
                setTimeout(loadLayers, 50);
            }, 200);
        } else {
            addRouteLayers();
            // Load layers immediately after adding routes
            setTimeout(loadLayers, 50);
        }

        setupMapInteractions();
        initializeDateInputs();
        UI.toggleFetch(false);
        UI.refs.menu.style.display = 'block';
        
        fitMapToData();
    }

    function initMap() {
        mapboxgl.accessToken = CONFIG.MAPBOX_TOKEN;
        const isMobile = window.innerWidth <= 768;
        state.map = new mapboxgl.Map({
            container: 'map', style: 'mapbox://styles/mapbox/dark-v10',
            center: [10.4515, 51.1657], zoom: isMobile ? 5 : 6, pitch: isMobile ? 0 : 15,
            attributionControl: false, fadeDuration: 0, antialias: true, renderWorldCopies: false,
            // Mobile-specific optimizations
            touchZoomRotate: true,
            touchPitch: false,
            dragRotate: !isMobile,
            maxZoom: 20,
            // Ensure proper rendering on mobile
            preserveDrawingBuffer: isMobile
        });

        try {
            const gl2 = document.createElement('canvas').getContext('webgl2');
            if (!gl2) throw new Error('No WebGL2');
            state.deck = new deck.MapboxOverlay({ interleaved: false, layers: [] });
            state.map.addControl(state.deck);
            state.useDeckGL = true;
        } catch (e) { state.useDeckGL = false; }

        state.map.on('style.load', () => { state.map.setFog({ 'high-color': 'rgb(36, 92, 223)', 'horizon-blend': 0.4 }); });
        state.map.on('load', () => {
            // Add a small delay for mobile to ensure proper loading
            const addLayersDelay = RouteAnimation.isMobile() ? 100 : 0;
            
            setTimeout(() => {
                try {
                    state.map.addLayer({
                        id: 'open-railway-map', type: 'raster',
                        source: { type: 'raster', tiles: ['https://a.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png'], tileSize: 256 },
                        layout: { visibility: state.railway.enabled ? 'visible' : 'none' }, paint: { 'raster-opacity': 0.15 }, minzoom: 0, maxzoom: 22
                    });
                } catch (e) {
                    console.warn('Failed to add open railway map layer:', e);
                }
            }, addLayersDelay);
            
            // Update heatmap on map move - longer debounce on mobile
            let heatmapUpdateTimeout = null;
            const debounceTime = RouteAnimation.isMobile() ? 400 : 200;
            
            state.map.on('moveend', () => {
                if (state.heatmap.enabled) {
                    // Clear any existing timeout
                    if (heatmapUpdateTimeout) {
                        clearTimeout(heatmapUpdateTimeout);
                        heatmapUpdateTimeout = null;
                    }
                    
                    heatmapUpdateTimeout = setTimeout(() => {
                        try {
                            updateRouteDensity();
                        } catch (error) {
                            console.error('Error updating heatmap on move:', error);
                        }
                    }, debounceTime);
                }
            });
        });
        setupEventListeners();
    }

    function fitMapToData() {
        const bounds = new mapboxgl.LngLatBounds();
        let hasPoints = false;
        state.layers.data.forEach(layer => {
            if (!layer.visible) return;
            layer.data.features.forEach(f => {
                f.geometry?.coordinates?.forEach(c => { if (c?.length >= 2) { bounds.extend(c); hasPoints = true; } });
            });
        });
        if (hasPoints) state.map.fitBounds(bounds, { padding: 50, maxZoom: 12 });
    }

    // =========================================================================
    // EVENT LISTENERS & UI
    // =========================================================================
    function setupEventListeners() {
        document.getElementById('statsToggle').onclick = () => document.getElementById('statsPanel').classList.toggle('active');
        document.getElementById('railwayToggle').onclick = () => {
            state.railway.enabled = !state.railway.enabled;
            if (state.map && state.map.getLayer('open-railway-map')) {
                state.map.setLayoutProperty('open-railway-map', 'visibility', state.railway.enabled ? 'visible' : 'none');
            } else {
                // Layer not loaded yet, try again after a delay
                setTimeout(() => {
                    if (state.map && state.map.getLayer('open-railway-map')) {
                        state.map.setLayoutProperty('open-railway-map', 'visibility', state.railway.enabled ? 'visible' : 'none');
                    }
                }, RouteAnimation.isMobile() ? 300 : 100);
            }
        };
        
        // Initialize hide inaccurate state from checkbox
        state.filters.hideInaccurate = document.getElementById('inaccurateDataToggle').checked;
        document.getElementById('heatmapToggle').onchange = (e) => toggleHeatmap(e.target.checked);
        document.getElementById('intensitySlider').oninput = (e) => {
            const newIntensity = parseInt(e.target.value);
            state.heatmap.intensity = newIntensity;
            document.getElementById('intensityValue').textContent = e.target.value;

            // Instantly update colors if heatmap is enabled and has cached data
            if (state.heatmap.enabled && state.heatmap.densityCache) {
                updateHeatmapColors();
            }
        };
        document.getElementById('inaccurateDataToggle').onchange = () => {
            state.filters.hideInaccurate = document.getElementById('inaccurateDataToggle').checked;
            reloadAllLayers();
        };
        document.getElementById('dateFrom').onchange = applyTimeFilter;
        document.getElementById('dateTo').onchange = applyTimeFilter;
        document.getElementById('shareBtn').onclick = shareView;
        document.getElementById('logoutBtn').onclick = logout;
        const animateToggle = document.getElementById('animateToggle');
        if (animateToggle) {
            // Initialize state from checkbox
            state.heatmap.animate = animateToggle.checked;
            
            animateToggle.onchange = (e) => {
                state.heatmap.animate = e.target.checked;
                if (state.heatmap.enabled) {
                    if (state.heatmap.animate) {
                        RouteAnimation.start();
                    } else {
                        RouteAnimation.stop();
                    }
                }
            };
        }
        
        // New menu event listeners
        const menuValidateBtn = document.getElementById('menuValidateBtn');
        const menuCopyTokenBtn = document.getElementById('menuCopyTokenBtn');
        const menuFetchBtn = document.getElementById('menuFetchBtn');
        const menuApiToken = document.getElementById('menuApiToken');
        const menuUsername = document.getElementById('menuUsername');
        
        if (menuValidateBtn) {
            menuValidateBtn.onclick = async () => {
                const token = menuApiToken.value.trim();
                if (!token) {
                    UI.setTokenStatus('Please enter a token', 'error');
                    return;
                }
                menuValidateBtn.disabled = true;
                UI.setTokenStatus('Validating...', 'idle');
                try {
                    const api = new TraewellingAPI(token);
                    const user = await api.getAuthenticatedUser();
                    state.tokenOwner = {
                        username: user.data.username,
                        displayName: user.data.displayName,
                        avatar: user.data.profilePicture,
                        profileUrl: `https://traewelling.de/profile/${user.data.username}`,
                        validated: true
                    };
                    UI.setTokenOwner(state.tokenOwner);
                    UI.setTokenStatus('Token valid', 'success');
                    state.token = token;
                    UI.syncTokenInputs(token);
                } catch (error) {
                    UI.setTokenStatus('Invalid token', 'error');
                    state.tokenOwner.validated = false;
                } finally {
                    menuValidateBtn.disabled = false;
                }
            };
        }
        
        if (menuCopyTokenBtn) {
            menuCopyTokenBtn.onclick = () => {
                const token = menuApiToken.value;
                if (!token) return;
                navigator.clipboard.writeText(token).then(() => {
                    menuCopyTokenBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        menuCopyTokenBtn.textContent = 'Copy Token';
                    }, 2000);
                });
            };
        }
        
        if (menuFetchBtn) {
            menuFetchBtn.onclick = () => {
                const token = menuApiToken.value.trim();
                const username = menuUsername.value.trim();
                if (!token) {
                    UI.setTokenStatus('Please validate token first', 'error');
                    return;
                }
                if (!username) {
                    alert('Please enter a username to query');
                    return;
                }
                state.token = token;
                state.username = username;
                UI.syncTokenInputs(token);
                UI.syncUsernameInput(username);
                startDataFetch();
            };
        }
    }

    function setupMapInteractions() {
        const layers = CONFIG.LAYER_CONFIG.filter(([id]) => state.map.getLayer(id)).map(([id]) => id);
        state.map.on('click', (e) => {
            let features = state.map.queryRenderedFeatures(e.point, { layers });
            if (!features.length) {
                const bbox = [[e.point.x-10, e.point.y-10], [e.point.x+10, e.point.y+10]];
                features = state.map.queryRenderedFeatures(bbox, { layers });
            }
            if (features.length) showPopup(e.lngLat, features[0]);
        });
        state.map.on('moveend', () => { if (state.heatmap.enabled) setTimeout(() => updateRouteDensity(), 200); });
    }

    function showPopup(lngLat, feature) {
        if (state.currentPopup) state.currentPopup.remove();
        const props = feature.properties || {};
        let train = props.train;
        if (typeof train === 'string') try { train = JSON.parse(train); } catch (e) { train = {}; }
        train = train || {};

        const statusId = props.statusId || 'unknown';
        const lineName = train.lineName || train.number || 'Unknown';
        const origin = train.origin?.name || 'Unknown';
        const dest = train.destination?.name || 'Unknown';
        const distance = Math.round((train.distance || 0) / 10) / 100;
        const category = feature.layer?.id || 'Unknown';

        const html = `<div class="popup-content">
            <strong>${category} ${lineName}</strong>
            <p><strong>${origin}</strong> ‚Üí <strong>${dest}</strong></p>
            <p>Distance: ${distance} km</p>
            ${statusId !== 'unknown' ? `<p><a href="https://traewelling.de/status/${statusId}" target="_blank" class="popup-link">View on Tr√§welling ‚Üí</a></p>` : ''}
        </div>`;

        state.currentPopup = new mapboxgl.Popup({ className: 'route-popup', closeButton: false, closeOnClick: true })
            .setLngLat(lngLat).setHTML(html).addTo(state.map);
    }

    function loadLayers() {
        const layerList = document.getElementById('layerList');
        if (!layerList) {
            console.warn('Layer list not found in DOM, retrying...');
            // Retry after a short delay
            setTimeout(() => {
                const retryList = document.getElementById('layerList');
                if (retryList) {
                    console.log('Layer list found on retry, loading layers...');
                    loadLayers();
                }
            }, 200);
            return;
        }
        
        // Clear existing layer items and their event listeners
        layerList.innerHTML = '';
        
        // Shared dragged item variable for all layer items
        let draggedItem = null;
        
        // Create layer items in the order defined in state (bottom to top)
        // This matches v4 behavior where menu shows from bottom layer to top layer
        state.layers.order.forEach((layerId) => {
            const layer = state.layers.data.get(layerId);
            if (!layer) return;
            
            // Create layer UI
            const layerItem = document.createElement('div');
            layerItem.className = 'layer-item' + (layer.visible ? ' active' : '');
            layerItem.draggable = true;
            layerItem.dataset.layerId = layerId;
            layerItem.innerHTML = `
                <span class="layer-name">${layerId}</span>
                <span class="layer-status">${layer.visible ? 'ON' : 'OFF'}</span>
            `;
            
            // Add click handler
            layerItem.addEventListener('click', (e) => {
                // Don't toggle if we just finished dragging
                if (layerItem.classList.contains('dragging')) {
                    return;
                }
                toggleLayer(layerId);
            });
            
            // Add drag and drop handlers
            layerItem.addEventListener('dragstart', (e) => {
                draggedItem = layerItem;
                layerItem.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', layerItem.innerHTML);
            });
            
            layerItem.addEventListener('dragend', (e) => {
                layerItem.classList.remove('dragging');
                draggedItem = null;
            });
            
            layerItem.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (draggedItem && draggedItem !== layerItem) {
                    layerItem.classList.add('drag-over');
                }
            });
            
            layerItem.addEventListener('dragleave', (e) => {
                layerItem.classList.remove('drag-over');
            });
            
            layerItem.addEventListener('drop', (e) => {
                e.preventDefault();
                layerItem.classList.remove('drag-over');
                
                if (draggedItem && draggedItem !== layerItem) {
                    const draggedLayerId = draggedItem.dataset.layerId;
                    const targetLayerId = layerItem.dataset.layerId;
                    
                    // Get current positions
                    const draggedIndex = state.layers.order.indexOf(draggedLayerId);
                    const targetIndex = state.layers.order.indexOf(targetLayerId);
                    
                    // Remove from old position
                    state.layers.order.splice(draggedIndex, 1);
                    // Insert at new position
                    state.layers.order.splice(targetIndex, 0, draggedLayerId);
                    
                    // Reload layers to reflect new order
                    reloadAllLayers();
                }
            });
            
            layerList.appendChild(layerItem);
        });
    }

    function toggleLayer(layerId) {
        const layer = state.layers.data.get(layerId);
        if (!layer) return;
        layer.visible = !layer.visible;
        
        // Only update visibility if heatmap is not enabled
        if (!state.heatmap.enabled) {
            state.map.setLayoutProperty(layerId, 'visibility', layer.visible ? 'visible' : 'none');
        }
        
        loadLayers();
        updateAllStatistics();
        if (state.heatmap.enabled) updateRouteDensity(true);
    }

    // =========================================================================
    // HIGH-PERFORMANCE ANIMATION MODULE
    // Pre-computes all positions once, uses index-based animation
    // =========================================================================
    const RouteAnimation = {
        // Configuration
        config: {
            maxRoutes: 80,
            mobileMaxRoutes: 50,
            pointsPerRoute: 300,        // Fixed points per route for consistent speed
            updateInterval: 16,         // ~60fps
            lastUpdate: 0,
            colors: {
                nationalExpress: [0, 115, 255],
                national: [0, 238, 255],
                regionalExp: [209, 2, 78],
                regional: [166, 2, 108],
                suburban: [252, 0, 0],
                bus: [35, 132, 67],
                tram: [47, 197, 204],
                subway: [246, 154, 0],
                plane: [80, 80, 80],
                ship: [0, 85, 170],
                unknown: [136, 136, 136],
                default: [255, 255, 255]
            },
            speeds: {
                plane: 2.0, nationalExpress: 1.6, national: 1.4, regionalExp: 1.2,
                regional: 1.0, suburban: 0.9, bus: 0.8, tram: 0.7, subway: 0.6, ship: 0.5, unknown: 1.0
            }
        },
        
        // Pre-computed animation data (computed once when routes change)
        data: {
            routes: null,           // Array of pre-computed route positions
            key: null,              // Cache invalidation key
            positions: null,        // Float32Array of all positions [x,y,x,y,...]
            colors: null,           // Uint8Array of all colors [r,g,b,a,...]
            routeCount: 0
        },
        
        isMobile() {
            return window.innerWidth <= 768 || 'ontouchstart' in window;
        },
        
        getColor(category) {
            return this.config.colors[category] || this.config.colors.default;
        },
        
        // Interpolate route to exactly N evenly-spaced points
        interpolateToFixedPoints(coords, numPoints) {
            if (coords.length < 2) return null;
            
            // Calculate cumulative distances
            const distances = [0];
            for (let i = 1; i < coords.length; i++) {
                const dx = (coords[i][0] - coords[i-1][0]) * 111320;
                const dy = (coords[i][1] - coords[i-1][1]) * 110540;
                distances.push(distances[i-1] + Math.sqrt(dx*dx + dy*dy));
            }
            
            const totalDist = distances[distances.length - 1];
            if (totalDist < 100) return null; // Skip routes shorter than 100m
            
            // Create evenly spaced points
            const result = new Float32Array(numPoints * 2);
            const step = totalDist / (numPoints - 1);
            
            let coordIdx = 0;
            for (let i = 0; i < numPoints; i++) {
                const targetDist = i * step;
                
                // Find segment containing this distance
                while (coordIdx < distances.length - 2 && distances[coordIdx + 1] < targetDist) {
                    coordIdx++;
                }
                
                // Interpolate within segment
                const segStart = distances[coordIdx];
                const segEnd = distances[coordIdx + 1];
                const t = segEnd > segStart ? (targetDist - segStart) / (segEnd - segStart) : 0;
                
                result[i * 2] = coords[coordIdx][0] + (coords[coordIdx + 1][0] - coords[coordIdx][0]) * t;
                result[i * 2 + 1] = coords[coordIdx][1] + (coords[coordIdx + 1][1] - coords[coordIdx][1]) * t;
            }
            
            return result;
        },
        
        // Build all animation data once
        buildAnimationData() {
            const cacheKey = state.layers.order
                .filter(id => state.layers.data.get(id)?.visible)
                .join('-');
            
            if (this.data.routes && this.data.key === cacheKey) {
                return true;
            }
            
            const isMobile = this.isMobile();
            const maxRoutes = isMobile ? this.config.mobileMaxRoutes : this.config.maxRoutes;
            const pointsPerRoute = this.config.pointsPerRoute;
            
            // Collect routes with usage count (one dot per unique route)
            const routeMap = new Map();
            
            state.layers.data.forEach((layer, categoryId) => {
                if (!layer.visible) return;
                const color = this.getColor(categoryId);
                const speed = this.config.speeds[categoryId] || 1.0;
                
                layer.data.features.forEach(feature => {
                    const coords = feature.geometry?.coordinates;
                    if (!coords || coords.length < 2) return;
                    
                    // Deduplication key (start + end, without category to allow cross-layer dedup)
                    const routeKey = `${coords[0][0].toFixed(3)},${coords[0][1].toFixed(3)}-${coords[coords.length-1][0].toFixed(3)},${coords[coords.length-1][1].toFixed(3)}`;
                    
                    const existing = routeMap.get(routeKey);
                    if (existing) {
                        // Increment usage count for existing route
                        existing.usageCount++;
                    } else {
                        // New route - interpolate and store
                        const positions = this.interpolateToFixedPoints(coords, pointsPerRoute);
                        if (positions) {
                            routeMap.set(routeKey, { 
                                positions, 
                                color, 
                                speed, 
                                category: categoryId,
                                usageCount: 1
                            });
                        }
                    }
                });
            });
            
            // Convert to array and sort by usage count (most used first)
            let routes = Array.from(routeMap.values());
            routes.sort((a, b) => b.usageCount - a.usageCount);
            
            // Take top N most used routes, ensuring mix of categories
            const selectedRoutes = [];
            const categoryCount = new Map();
            const minPerCategory = Math.floor(maxRoutes / 6); // Ensure category diversity
            
            // First pass: ensure minimum routes per category
            for (const route of routes) {
                const cat = route.category;
                const count = categoryCount.get(cat) || 0;
                if (count < minPerCategory && selectedRoutes.length < maxRoutes) {
                    selectedRoutes.push(route);
                    categoryCount.set(cat, count + 1);
                }
            }
            
            // Second pass: fill remaining slots with most used routes
            for (const route of routes) {
                if (selectedRoutes.length >= maxRoutes) break;
                if (!selectedRoutes.includes(route)) {
                    selectedRoutes.push(route);
                }
            }
            
            // Store pre-computed data
            this.data.routes = selectedRoutes;
            this.data.key = cacheKey;
            this.data.routeCount = selectedRoutes.length;
            
            return selectedRoutes.length > 0;
        },
        
        // Ultra-fast layer creation - just pick positions at current time
        createLayer() {
            if (!this.buildAnimationData() || this.data.routeCount === 0) return null;
            
            const routes = this.data.routes;
            const time = performance.now() / 1000;
            const pointsPerRoute = this.config.pointsPerRoute;
            const zoom = state.map?.getZoom() || 12;
            const isMobile = this.isMobile();
            
            // Size based on zoom
            const baseSize = isMobile ? 18 : 24;
            const sizeMultiplier = Math.pow(1.12, zoom - 12);
            const dotSize = baseSize * Math.min(1.8, Math.max(0.4, sizeMultiplier));
            
            // Pre-allocate particle array (2 particles per route: glow + core)
            const particles = new Array(routes.length * 2);
            
            for (let i = 0; i < routes.length; i++) {
                const route = routes[i];
                const positions = route.positions;
                const color = route.color;
                
                // Calculate current position index (back-and-forth animation)
                const speed = route.speed * 0.3;
                const phase = i * 0.1; // Offset each route
                const rawT = ((time * speed + phase) % 2);
                const t = rawT <= 1 ? rawT : 2 - rawT; // Ping-pong
                
                // Get position directly from pre-computed array
                const idx = Math.min(Math.floor(t * (pointsPerRoute - 1)), pointsPerRoute - 2);
                const frac = (t * (pointsPerRoute - 1)) - idx;
                const idx2 = idx * 2;
                
                // Interpolate between two pre-computed points
                const x = positions[idx2] + (positions[idx2 + 2] - positions[idx2]) * frac;
                const y = positions[idx2 + 1] + (positions[idx2 + 3] - positions[idx2 + 1]) * frac;
                
                // Glow particle
                particles[i * 2] = {
                    position: [x, y],
                    radius: dotSize * 1.8,
                    color: [color[0], color[1], color[2], 50]
                };
                
                // Core particle
                particles[i * 2 + 1] = {
                    position: [x, y],
                    radius: dotSize,
                    color: [color[0], color[1], color[2], 255]
                };
            }
            
            return [new deck.ScatterplotLayer({
                id: 'animated-routes',
                data: particles,
                getPosition: d => d.position,
                getRadius: d => d.radius,
                getFillColor: d => d.color,
                opacity: 1,
                radiusMinPixels: 2,
                radiusMaxPixels: 25,
                pickable: false,
                updateTriggers: { getPosition: time },
                parameters: { depthTest: false }
            })];
        },
        
        start() {
            if (state.heatmap.animationFrameId) return;
            this.animate();
        },
        
        stop() {
            if (state.heatmap.animationFrameId) {
                cancelAnimationFrame(state.heatmap.animationFrameId);
                state.heatmap.animationFrameId = null;
            }
            state.deckLayers = state.deckLayers.filter(l => !l.id.startsWith('animated-routes'));
            if (state.deck?.setProps) {
                state.deck.setProps({ layers: state.deckLayers });
            }
        },
        
        animate() {
            if (!state.heatmap.enabled || !state.heatmap.animate) {
                this.stop();
                return;
            }
            
            if (document.hidden) {
                state.heatmap.animationFrameId = requestAnimationFrame(() => this.animate());
                return;
            }
            
            const now = performance.now();
            if (now - this.config.lastUpdate < this.config.updateInterval) {
                state.heatmap.animationFrameId = requestAnimationFrame(() => this.animate());
                return;
            }
            this.config.lastUpdate = now;
            
            const layers = this.createLayer();
            if (layers) {
                state.deckLayers = state.deckLayers.filter(l => !l.id.startsWith('animated-routes'));
                state.deckLayers.push(...layers);
                if (state.deck?.setProps) {
                    state.deck.setProps({ layers: state.deckLayers });
                }
            }
            
            state.heatmap.animationFrameId = requestAnimationFrame(() => this.animate());
        },
        
        invalidateCache() {
            this.data.routes = null;
            this.data.key = null;
        }
    };
    
    // =========================================================================
    // HEATMAP FUNCTIONS
    // =========================================================================
    function toggleHeatmap(enabled) {
        state.heatmap.enabled = enabled;
        if (enabled) {
            // Completely hide Mapbox layers
            state.layers.data.forEach((layer, id) => { 
                state.map.setLayoutProperty(id, 'visibility', 'none'); 
            });
            updateRouteDensity(true);
            // Check if animation toggle is checked
            const animateToggle = document.getElementById('animateToggle');
            if (animateToggle && animateToggle.checked) {
                RouteAnimation.start();
            }
        } else {
            // Restore Mapbox layers visibility
            state.layers.data.forEach((layer, id) => { 
                if (layer.visible) {
                    state.map.setLayoutProperty(id, 'visibility', 'visible');
                    state.map.setPaintProperty(id, 'line-opacity', 0.8);
                }
            });
            RouteAnimation.stop();
            state.deckLayers = state.deckLayers.filter(l => l.id !== 'route-heatmap');
            if (state.deck?.setProps) state.deck.setProps({ layers: state.deckLayers });
        }
    }

    function updateRouteDensity(force = false) {
        if (!state.heatmap.enabled || !state.useDeckGL) return;
        
        // Invalidate animation cache when density updates
        RouteAnimation.invalidateCache();
        
        const segmentMap = new Map();
        state.layers.data.forEach((layer) => {
            if (!layer.visible) return;
            layer.data.features.forEach(f => {
                const coords = f.geometry?.coordinates;
                if (!coords || coords.length < 2) return;
                for (let j = 0; j < coords.length - 1; j++) {
                    const [x1,y1] = coords[j], [x2,y2] = coords[j+1];
                    const key = `${Math.round(x1*1e5)/1e5},${Math.round(y1*1e5)/1e5}-${Math.round(x2*1e5)/1e5},${Math.round(y2*1e5)/1e5}`;
                    segmentMap.set(key, (segmentMap.get(key) || 0) + 1);
                }
            });
        });

        const lineData = [];
        segmentMap.forEach((count, key) => {
            const [s, t] = key.split('-');
            lineData.push({ source: s.split(',').map(Number), target: t.split(',').map(Number), density: count });
        });

        state.heatmap.densityCache = lineData;
        const intensity = (state.heatmap.intensity * 3) / 4;
        
        const heatmapLayer = new deck.LineLayer({
            id: 'route-heatmap', 
            data: lineData, 
            opacity: 0.25,  // Match v4 opacity
            getSourcePosition: d => d.source, 
            getTargetPosition: d => d.target,
            getColor: d => { 
                // Use v4's color calculation
                const normalizedDensity = (d.density * 6) / intensity;
                return [
                    Math.min(255, normalizedDensity * 25),
                    Math.min(255, 128 * (1 - normalizedDensity * 0.15)),
                    Math.min(255, 255 * (1 - normalizedDensity * 0.15)),
                    150  // Alpha value
                ];
            },
            getWidth: 3,  // Match v4 width
            pickable: false
        });
        
        // Update deck layers - ensure heatmap is below particles but above transport lines
        state.deckLayers = state.deckLayers.filter(l => l.id !== 'route-heatmap');
        
        // Find the right position to insert heatmap layer (before animated routes)
        const particleIndex = state.deckLayers.findIndex(l => l.id === 'animated-routes');
        if (particleIndex !== -1) {
            state.deckLayers.splice(particleIndex, 0, heatmapLayer);
        } else {
            state.deckLayers.push(heatmapLayer);
        }
        
        if (state.deck?.setProps) state.deck.setProps({ layers: state.deckLayers });
    }
    
    // Instant color update using cached density data (like v4)
    function updateHeatmapColors() {
        if (!state.heatmap.densityCache || !state.useDeckGL) return;

        // Find and update the existing heatmap layer instead of recreating it
        const heatmapIndex = state.deckLayers.findIndex(l => l.id === 'route-heatmap');
        if (heatmapIndex !== -1) {
            // Create new layer with updated colors
            const intensity = (state.heatmap.intensity * 3) / 4;
            
            const newHeatmapLayer = new deck.LineLayer({
                id: 'route-heatmap', 
                data: state.heatmap.densityCache, 
                opacity: 0.25,
                getSourcePosition: d => d.source, 
                getTargetPosition: d => d.target,
                getColor: d => { 
                    const normalizedDensity = (d.density * 6) / intensity;
                    return [
                        Math.min(255, normalizedDensity * 25),
                        Math.min(255, 128 * (1 - normalizedDensity * 0.15)),
                        Math.min(255, 255 * (1 - normalizedDensity * 0.15)),
                        150
                    ];
                },
                getWidth: 3,
                pickable: false
            });

            // Replace the old layer
            state.deckLayers[heatmapIndex] = newHeatmapLayer;

            // Update deck with minimal re-rendering
            if (state.deck?.setProps) {
                state.deck.setProps({ layers: [...state.deckLayers] });
            }
        }
    }

    function reloadAllLayers() {
        // Store current visibility states
        const visibilityStates = new Map();
        state.layers.data.forEach((layer, id) => { visibilityStates.set(id, layer.visible); });
        
        // Clear and recreate all layers with current filters
        state.layers.data.clear();
        CONFIG.LAYER_CONFIG.forEach(([id]) => {
            if (state.map?.getLayer(id)) state.map.removeLayer(id);
            if (state.map?.getSource(id)) state.map.removeSource(id);
        });
        
        const categories = processTripsToGeoJSON(state.fetchedTrips);
        state.layers.order.forEach((id, index) => {
            let data = categories[id] || { type: 'FeatureCollection', features: [] };
            if (state.filters.hideInaccurate) data = filterInaccurateData(data, id);
            
            // Add layer to map
            state.map.addSource(id, { type: 'geojson', data: data });
            state.map.addLayer({
                id: id,
                type: 'line',
                source: id,
                layout: { 
                    'line-join': 'round',
                    'line-cap': 'round',
                    'visibility': state.heatmap.enabled ? 'none' : (visibilityStates.get(id) ? 'visible' : 'none')
                },
                paint: {
                    'line-color': CONFIG.LAYER_CONFIG.find(c => c[0] === id)[1],
                    'line-width': ['interpolate', ['linear'], ['zoom'], 12, 3, 18, 16],
                    'line-opacity': 0.8
                }
            }, index > 0 ? state.layers.order[index - 1] : 'open-railway-map');
            
            state.layers.data.set(id, {
                data: data,
                color: CONFIG.LAYER_CONFIG.find(c => c[0] === id)[1],
                visible: visibilityStates.get(id) || false
            });
        });
        
        updateAllStatistics();
        if (state.heatmap.enabled) updateRouteDensity(true);
        
        // Update the layer menu
        loadLayers();
    }

    function applyTimeFilter() {
        const from = document.getElementById('dateFrom').value || null;
        const to = document.getElementById('dateTo').value || null;
        state.filters.fromDate = from; state.filters.toDate = to;

        const filtered = state.fetchedTrips.filter(trip => {
            if (!trip.createdAt) return true;
            const d = new Date(trip.createdAt);
            if (from && d < new Date(from + 'T00:00:00Z')) return false;
            if (to && d > new Date(to + 'T23:59:59Z')) return false;
            return true;
        });

        const categories = processTripsToGeoJSON(filtered);
        state.layers.order.forEach(layerId => {
            let data = categories[layerId] || { type: 'FeatureCollection', features: [] };
            if (state.filters.hideInaccurate) data = filterInaccurateData(data, layerId);
            const source = state.map.getSource(layerId);
            if (source) source.setData(data);
            const layer = state.layers.data.get(layerId);
            if (layer) layer.data = data;
        });
        updateAllStatistics();
        if (state.heatmap.enabled) updateRouteDensity(true);
    }

    // =========================================================================
    // STATISTICS
    // =========================================================================
    function resetStatistics() {
        state.statistics = { trips: 0, distance: 0, lineCounts: {}, typeCounts: {}, oldestDate: null, newestDate: null, oldestStatusId: null, newestStatusId: null };
    }

    function updateStatistics(data, category) {
        data.features.forEach(f => {
            let train = f.properties?.train;
            if (typeof train === 'string') try { train = JSON.parse(train); } catch (e) { train = {}; }
            train = train || {};
            const distance = train.distance || 0;
            const createdAt = f.properties?.createdAt;
            const statusId = f.properties?.statusId;

            state.statistics.trips++;
            state.statistics.distance += distance;

            const lineName = train.lineName || train.number || 'Unknown';
            state.statistics.lineCounts[lineName] = (state.statistics.lineCounts[lineName] || 0) + 1;
            state.statistics.typeCounts[category] = (state.statistics.typeCounts[category] || 0) + 1;

            if (createdAt) {
                const d = new Date(createdAt);
                if (!state.statistics.oldestDate || d < state.statistics.oldestDate) { state.statistics.oldestDate = d; state.statistics.oldestStatusId = statusId; }
                if (!state.statistics.newestDate || d > state.statistics.newestDate) { state.statistics.newestDate = d; state.statistics.newestStatusId = statusId; }
            }
        });
        refreshStatsDisplay();
    }

    function updateAllStatistics() {
        resetStatistics();
        state.layers.data.forEach((layer, id) => { if (layer.visible) updateStatistics(layer.data, id); });
    }

    function refreshStatsDisplay() {
        document.getElementById('statTrips').textContent = state.statistics.trips;
        document.getElementById('statDistance').textContent = Math.round(state.statistics.distance / 1000 * 100) / 100 + ' km';

        const mostLine = Object.entries(state.statistics.lineCounts).sort((a,b) => b[1]-a[1])[0];
        document.getElementById('statLine').textContent = mostLine ? mostLine[0] : '-';

        const mostType = Object.entries(state.statistics.typeCounts).sort((a,b) => b[1]-a[1])[0];
        document.getElementById('statType').textContent = mostType ? mostType[0] : '-';

        const oldest = state.statistics.oldestDate;
        const newest = state.statistics.newestDate;
        document.getElementById('statOldestDate').innerHTML = oldest && state.statistics.oldestStatusId
            ? `<a href="https://traewelling.de/status/${state.statistics.oldestStatusId}" target="_blank" class="popup-link">${oldest.toLocaleDateString('de-DE')}</a>` : '-';
        document.getElementById('statNewestDate').innerHTML = newest && state.statistics.newestStatusId
            ? `<a href="https://traewelling.de/status/${state.statistics.newestStatusId}" target="_blank" class="popup-link">${newest.toLocaleDateString('de-DE')}</a>` : '-';
    }

    function initializeDateInputs() {
        const oldest = state.statistics.oldestDate;
        const newest = state.statistics.newestDate;
        if (oldest && newest) {
            const fromEl = document.getElementById('dateFrom'), toEl = document.getElementById('dateTo');
            const oldStr = oldest.toISOString().split('T')[0], newStr = newest.toISOString().split('T')[0];
            fromEl.min = oldStr; fromEl.max = newStr; toEl.min = oldStr; toEl.max = newStr;
        }
    }

    function shareView() {
        const center = state.map.getCenter(), zoom = state.map.getZoom();
        const url = window.location.origin + window.location.pathname + '#map=' + zoom + '/' + center.lat + '/' + center.lng;
        if (navigator.clipboard?.writeText) {
            navigator.clipboard.writeText(url).then(() => {
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:20px;right:20px;background:#4CAF50;color:white;padding:10px 20px;border-radius:5px;z-index:10000;';
                msg.textContent = 'Link copied!';
                document.body.appendChild(msg);
                setTimeout(() => msg.remove(), 2000);
            });
        } else {
            prompt('Share this link:', url);
        }
    }

    // =========================================================================
    // TOKEN AUTO-VALIDATION
    // =========================================================================
    async function validateStoredToken(token) {
        try {
            const api = new TraewellingAPI(token);
            const user = await api.getAuthenticatedUser();
            state.tokenOwner = {
                username: user.data.username,
                displayName: user.data.displayName,
                avatar: user.data.profilePicture,
                profileUrl: `https://traewelling.de/profile/${user.data.username}`,
                validated: true
            };
            state.token = token;
            UI.setTokenOwner(state.tokenOwner);
            UI.setTokenStatus('Token valid', 'success');
            UI.syncTokenInputs(token);
        } catch (error) {
            console.warn('Auto-validation failed:', error);
            UI.setTokenStatus('Token expired', 'error');
            // Clear invalid token
            localStorage.removeItem('tw_token');
            state.token = null;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================
    // Make session functions globally accessible for onclick handlers
    window.loadSession = loadSession;
    window.deleteSession = deleteSession;
    
    document.addEventListener('DOMContentLoaded', () => {
        UI.init();
        loadSavedSessions();
        updateMenuAccountList();
        document.getElementById('startFetchBtn').onclick = startDataFetch;
        document.getElementById('cancelFetchBtn').onclick = cancelFetch;

        // Auto-validate stored token
        const storedToken = localStorage.getItem('tw_token');
        if (storedToken) {
            // Auto-validate token in background
            validateStoredToken(storedToken);
        }

        if (window.location.hash?.startsWith('#map=')) {
            const parts = window.location.hash.substring(5).split('/');
            if (parts.length === 3) {
                const [zoom, lat, lng] = parts.map(parseFloat);
                setTimeout(() => { if (state.map) state.map.jumpTo({ center: [lng, lat], zoom }); }, 1000);
            }
        }
    });
    </script>
</body>
</html>
